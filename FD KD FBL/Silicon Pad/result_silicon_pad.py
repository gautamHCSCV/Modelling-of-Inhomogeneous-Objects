# -*- coding: utf-8 -*-
"""Result_silicon_pad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GpIymOiUXfcJBXQ5wRU3bsJXLezF0VAt
"""

!pip install catboost

import pandas as pd
import numpy as np
import os
import csv
from datetime import datetime
from catboost import CatBoostRegressor
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split

import warnings
warnings.filterwarnings('ignore')

from google.colab import drive
drive.mount('/content/drive')

"""# Models Estimation"""

path = '/content/drive/MyDrive/Virtual env/z_inhomogenous_modeling/silicon_pad_all_data/'
print(len(sorted(os.listdir(path))))
rnd_idx = np.array([2,10,25,40,48,59,73,79,85,88,101,110,125,128,132,139,144,148,167,174,189])
len(rnd_idx)

y = np.array(pd.read_csv(path+f'{rnd_idx[0]}_percep_force_silicon_pad_data.csv'))
x = np.array(pd.read_csv(path+f'{rnd_idx[0]}_percep_pos_silicon_pad_data.csv'))
l = len(y)
x.shape, y.shape

for i in range(len(rnd_idx)-1):
    x1 = np.array(pd.read_csv(path+f'{rnd_idx[i+1]}_percep_pos_silicon_pad_data.csv')) # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{rnd_idx[i+1]}_percep_force_silicon_pad_data.csv'))

    x = np.concatenate([x,x1])
    y = np.concatenate([y,y1])
print(x.shape, y.shape)

y_test = np.array(pd.read_csv(path+f'{rnd_idx[3]-2}_force_silicon_pad_data.csv'))
x_test = np.array(pd.read_csv(path+f'{rnd_idx[3]-2}_pos_silicon_pad_data.csv'))

x_test.shape, y_test.shape

for i in range(len(rnd_idx)//2):
    x1 = np.array(pd.read_csv(path+f'{rnd_idx[i+1]-1}_pos_silicon_pad_data.csv')) # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{rnd_idx[i+1]-1}_force_silicon_pad_data.csv'))
    x_test = np.concatenate([x_test,x1])
    y_test = np.concatenate([y_test,y1])
print(x_test.shape, y_test.shape)

cat = CatBoostRegressor()
t1 = datetime.now()
cat.fit(x,y)
t2 = datetime.now()
y_pred = cat.predict(x_test)

print('RMSE:', mean_squared_error(y_pred, y_test)**0.5)
print(t2-t1)

error = []
for i in range(1,201):
    x1 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv')) # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
    y_pred = cat.predict(x1)
    statement = f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}\n'
    #print(f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}')
    error.append(mean_squared_error(y_pred, y1)**0.5)
    with open('results_catboost.txt','a') as f:
        f.write(statement)
print(sum(error)/len(error))

print(np.std(np.array(error)))
max(error), min(error)

for i in range(5):
    val = sorted(error)[::-1][i]
    print(val, 'at', error.index(val)+1)

from matplotlib.pyplot import figure
from matplotlib.ticker import MaxNLocator
import warnings
warnings.filterwarnings('ignore')

i = 2
x1 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv')) # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
y_pred = cat.predict(x1)
error_cat = []
for j in range(len(y1)-5):
    error_cat.append(y1[j,0]-y_pred[j])

fig, (ax1, ax2) = plt.subplots(2, 1)
fig.set_figheight(5)
fig.set_figwidth(7)

ax1.plot(np.arange(0,12,0.001),y_test[:12000],label = 'Measured',linewidth=1.0)
#ax1.plot(np.arange(0,12,0.001),y1_pred[:12000],label = 'Random Forest',linewidth=0.8)
ax1.plot(np.arange(0,12,0.001),y_pred[:12000],label = 'Catboost',linewidth=1.0)
ax1.legend(loc = 'upper right')
ax1.set_xlim([0, 12])
ax1.set_ylim([0, int(max(y_pred[:12000])+2)])
ax1.set_ylabel('Force [N]',fontsize=13)
#ax1.set_xlabel('Time [s]',fontsize=13)
ax1.grid()

ax2.plot(np.arange(0,12,0.001),error_cat[:12000],label = 'Catboost',linewidth=0.8)
ax2.legend(loc = 'upper right')
ax2.set_xlim([0, 12])
ax2.set_ylim([-2, 2])
ax1.yaxis.set_major_locator(MaxNLocator(integer=True))
ax2.set_ylabel('Error [N]',fontsize=13)
ax2.set_xlabel('Time [s]',fontsize=13)
ax2.grid()

plt.savefig(f'obj5_measured_pred_{i}.eps')
plt.show()

"""# Random Forest"""

rf = RandomForestRegressor()
t1 = datetime.now()
rf.fit(x,y)
t2 = datetime.now()
y_pred = rf.predict(x_test)
print('RMSE:', mean_squared_error(y_pred, y_test)**0.5)
print(t2-t1)

error = []
for i in range(1,201):
    x1 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv')) # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
    y_pred = rf.predict(x1)
    statement = f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}\n'
    #print(f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}')
    error.append(mean_squared_error(y_pred, y1)**0.5)
    with open('results_RF.txt','a') as f:
        f.write(statement)
print(sum(error)/len(error))

print(sum(error)/len(error))
print(np.std(np.array(error)))
max(error), min(error)

"""# Clusterring"""

path2 = '/content/drive/MyDrive/Virtual env/z_inhomogenous_modeling/'
arr = np.array(pd.read_csv(path2+'x_y_silicon_pad.csv', names = ['x','y']))
print(arr.shape)
arr[:5]

from sklearn.cluster import KMeans
k_values = range(1, 11)

# Perform k-means clustering for each k value
inertia_values = []
for k in k_values:
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(arr)
    inertia_values.append(kmeans.inertia_)

# Plot the inertia values against the number of clusters
plt.plot(k_values, inertia_values, 'bx-')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Inertia')
plt.title('Elbow Method for Optimal k')
plt.show()

kmeans = KMeans(n_clusters=5)
kmeans.fit(arr)
kmeans.cluster_centers_

from collections import defaultdict
d = defaultdict(lambda: [])
for i in range(200):
    label = kmeans.predict([arr[i]])[0]
    d[label].append(i)

for i in range(5):
    print(d[i])

from scipy.linalg import norm

def dist(i):
    at = -1
    mini = 10
    for j in range(len(d[i])):
        dis = ((arr[d[i][j]][0]- kmeans.cluster_centers_[i][0])**2 + (arr[d[i][j]][1]- kmeans.cluster_centers_[i][1])**2)**0.5
        if dis <mini:
            mini = dis
            at = j
    print(f'{d[i][at]+1} is the master node of {i}th cluster')
    print(arr[d[i][at]], kmeans.cluster_centers_[i],'\n')
for i in range(5):
    dist(i)

x1 = np.array(pd.read_csv(path+f'{10}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{10}_force_silicon_pad_data.csv'))
rf1 = RandomForestRegressor()
rf1.fit(x1,y1)

from matplotlib.pyplot import figure
from matplotlib.ticker import MaxNLocator
import warnings
warnings.filterwarnings('ignore')

i = 2
x1 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv')) # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
y_pred = cat.predict(x1)
y_rf = rf.predict(x1)
y_cluster = rf1.predict(x1[:,:10])

error_cat = []
error_rf = []
error_cluster = []
for j in range(len(y1)-5):
    error_cat.append(y1[j,0]-y_pred[j])
    error_rf.append(y1[j,0]-y_rf[j])
    error_cluster.append(y1[j,0]-y_cluster[j])


fig, (ax1, ax2) = plt.subplots(2, 1)
fig.set_figheight(5)
fig.set_figwidth(7)

ax1.plot(np.arange(0,12,0.001),y_test[:12000],label = 'Measured',linewidth=1.0)
ax1.plot(np.arange(0,12,0.001),y_rf[:12000],label = 'Random Forest',linewidth=1.0)
ax1.plot(np.arange(0,12,0.001),y_cluster[:12000],label = 'Cluster',linewidth=1.0)
ax1.plot(np.arange(0,12,0.001),y_pred[:12000],label = 'Catboost',linewidth=1.0)

ax1.legend(loc = 'upper right')
ax1.set_xlim([0, 12])
ax1.set_ylim([0, int(max(y_pred[:12000])+2)])
ax1.set_ylabel('Force [N]',fontsize=13)
#ax1.set_xlabel('Time [s]',fontsize=13)
ax1.grid()

ax2.plot(np.arange(0,12,0.001),error_cluster[:12000],label = 'Cluster',linewidth=0.8)
ax2.plot(np.arange(0,12,0.001),error_rf[:12000],label = 'Random Forest',linewidth=0.8)
ax2.plot(np.arange(0,12,0.001),error_cat[:12000],label = 'Catboost',linewidth=0.8)

ax2.legend(loc = 'upper right')
ax2.set_xlim([0, 12])
ax2.set_ylim([-2, 2])
ax1.yaxis.set_major_locator(MaxNLocator(integer=True))
ax2.set_ylabel('Error [N]',fontsize=13)
ax2.set_xlabel('Time [s]',fontsize=13)
ax2.grid()

plt.savefig(f'obj5_measured_pred_{i}_all.eps')
plt.show()

x1 = np.array(pd.read_csv(path+f'{10}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{10}_force_silicon_pad_data.csv'))
rf = RandomForestRegressor()
rf.fit(x1,y1)

error = []
array = np.array(d[0])+1
for i in array:
    x2 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
    y_pred = rf.predict(x2)
    statement = f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}\n'
    #print(f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}')
    error.append(mean_squared_error(y_pred, y1)**0.5)
    with open('cluster.txt','a') as f:
        f.write(statement)
print(sum(error)/len(error))
print(max(error), min(error))
total = error

x1 = np.array(pd.read_csv(path+f'{196}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{196}_force_silicon_pad_data.csv'))
rf = RandomForestRegressor()
rf.fit(x1,y1)

error = []
array = np.array(d[1])+1
for i in array:
    x2 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
    y_pred = rf.predict(x2)
    statement = f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}\n'
    #print(f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}')
    error.append(mean_squared_error(y_pred, y1)**0.5)
    with open('cluster.txt','a') as f:
        f.write(statement)
print(sum(error)/len(error))
print(max(error), min(error))
total += error

x1 = np.array(pd.read_csv(path+f'{168}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{168}_force_silicon_pad_data.csv'))
rf = RandomForestRegressor()
rf.fit(x1,y1)

error = []
array = np.array(d[2])+1
for i in array:
    x2 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
    y_pred = rf.predict(x2)
    statement = f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}\n'
    #print(f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}')
    error.append(mean_squared_error(y_pred, y1)**0.5)
    with open('cluster.txt','a') as f:
        f.write(statement)
print(sum(error)/len(error))
print(max(error), min(error))
total += error

x1 = np.array(pd.read_csv(path+f'{88}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{88}_force_silicon_pad_data.csv'))
rf = RandomForestRegressor()
rf.fit(x1,y1)

error = []
array = np.array(d[3])+1
for i in array:
    x2 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
    y_pred = rf.predict(x2)
    statement = f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}\n'
    #print(f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}')
    error.append(mean_squared_error(y_pred, y1)**0.5)
    with open('cluster.txt','a') as f:
        f.write(statement)
print(sum(error)/len(error))
print(max(error), min(error))
total+= error

x1 = np.array(pd.read_csv(path+f'{189}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
y1 = np.array(pd.read_csv(path+f'{189}_force_silicon_pad_data.csv'))
rf = RandomForestRegressor()
rf.fit(x1,y1)

error = []
array = np.array(d[4])+1
for i in array:
    x2 = np.array(pd.read_csv(path+f'{i}_pos_silicon_pad_data.csv'))[:,:10] # fractional derivatives
    y1 = np.array(pd.read_csv(path+f'{i}_force_silicon_pad_data.csv'))
    y_pred = rf.predict(x2)
    statement = f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}\n'
    #print(f'For point: {i}, Error: {mean_squared_error(y_pred, y1)**0.5}')
    error.append(mean_squared_error(y_pred, y1)**0.5)
    with open('cluster.txt','a') as f:
        f.write(statement)
print(sum(error)/len(error))
print(max(error), min(error))
total += error

print('Mean:', np.mean(np.array(total)))
print('Std:', np.std(np.array(total)))

max(total)

